// Copyright Gunfire Games, LLC. All Rights Reserved.

#include "NavSvoTileGenerator.h"

#include "Gunfire3DNavData.h"
#include "Gunfire3DNavigationUtils.h"
#include "NavSvoGenerator.h"

FNavSvoTileGenerator::FNavSvoTileGenerator(const FNavSvoGenerator& InParent, const FNavSvoGeneratorConfig& InConfig)
	: Config(InConfig)
	, bIsComplete(false)
{
#if PROFILE_SVO_GENERATION
	CreateCycle = FPlatformTime::Cycles64();
#endif

	// Store a weak ptr to the parent
	ParentWeakPtr = InParent.AsShared();
}

void FNavSvoTileGenerator::DoWork()
{
	TSharedPtr<const FNavDataGenerator, ESPMode::ThreadSafe> ParentSharedPtr = ParentWeakPtr.Pin();

	if (!ParentSharedPtr.IsValid())
	{
		bIsComplete = true;
		return;
	}

	// We have to construct a temporary SVO for linking nodes, but we only use it for one
	// tile at a time, so modify the config to reflect that.
	Config.SetTilePoolSize(1);
	Config.SetTilePoolSizeFixed(true);

	const FNavSvoGenerator* Parent = static_cast<const FNavSvoGenerator*>(ParentSharedPtr.Get());
	ensure(Parent);

	const uint32 NumLeafNodes = Config.NumLeafNodesPerAxis * Config.NumLeafNodesPerAxis * Config.NumLeafNodesPerAxis;

	const uint32 NumVoxels = NumLeafNodes * SVO_VOXELS_PER_LEAF;

	GeneratedTiles.Reserve(Tiles.Num());

	BuildPaddingOffsetCodes();

	// Buffers we use during generation
	TBitArray<> Voxels;
	TBitArray<> PaddedVoxels;

	// Generate the tiles
	for (TSharedRef<FTileGenerationData>& TileRef : Tiles)
	{
		FTileGenerationData& Tile = TileRef.Get();

		// Add an SVO tile for this tile and initialize it to open. We always need to
		// return a tile, even if it just represents empty space.
		FSvoTile& BuiltTile = GeneratedTiles.Add_GetRef(FSvoTile(FSvoTile::CalcTileID(Tile.TileCoord), Config.GetTileLayerIndex(), Tile.TileCoord));
		BuiltTile.GetNodeInfo().SetNodeState(ENodeState::Open);

		Voxels.Init(false, NumVoxels);

		// Convert our input triangles into voxels. If this returns false there weren't
		// any triangles that actually overlapped our navigable space so we're done.
		if (FillVoxels(Tile, Voxels))
		{
			// The voxel data currently represents the exact blocked space, i.e., a voxel
			// could be marked as clear when the voxel next to it is completely filled
			// with collision. We need it to represent a space where an agent could be
			// centered at any location in the voxel and not be colliding. So, we pad out
			// the voxels by however many we need to ensure that an agent with the
			// specified radius can fit.
			PaddedVoxels.Init(false, NumVoxels);
			PadVoxels(Tile, Voxels, PaddedVoxels);

			// Now that we have all the voxelized space generated convert it into a tile
			// we can add to the octree.
			CreateTileFromVoxels(Tile, PaddedVoxels, BuiltTile);
		}
	}

	bIsComplete = true;
}

bool FNavSvoTileGenerator::AddTile(const FIntVector& TileCoord)
{
	TSharedPtr<const FNavDataGenerator, ESPMode::ThreadSafe> ParentSharedPtr = ParentWeakPtr.Pin();
	if (!ParentSharedPtr.IsValid())
	{
		return false;
	}

	const FNavSvoGenerator* Parent = static_cast<const FNavSvoGenerator*>(ParentSharedPtr.Get());
	ensure(Parent);

	const FVector& TileCenter = Config.TileCoordToLocation(TileCoord);
	const FBox TileBounds = FBox::BuildAABB(TileCenter, Config.GetTileExtent());

	const FVector PaddedTileMin = TileCenter - (Config.NumLeafNodesPerAxis * Config.GetLeafResolution() * 0.5f);
	const FBox PaddedBounds = TileBounds.ExpandBy(Config.BoundsPadding);

	FBox GatherBounds;
	GatherBounds.Init();

	TArray<FIntBox> VoxelBounds;

	// Collect all navigation bounds which overlap this tile
	for (const FBox& InclusionBounds : Parent->GetInclusionBounds())
	{
		// Build a bounding box that is the padded tile bounds clipped by any inclusion
		// volumes. 99% of the time this will just be the padded tile bounds, but if this
		// is at the edge of the inclusion volume it could be less.
		if (FGunfire3DNavigationUtils::AABBIntersectsAABB(InclusionBounds, PaddedBounds))
		{
			const FBox ClippedGenerationBounds = FGunfire3DNavigationUtils::CalculateAABBOverlap(InclusionBounds.ExpandBy(Config.BoundsPadding), PaddedBounds);

			GatherBounds += ClippedGenerationBounds;
		}

		// Build a list of the voxel bounds in tile space where we allow voxels. We use
		// this during final tile construction to clip any voxels generated by padding
		// that are outside the bounds. Typically this is just a single box that
		// encapsulates the entire tile.
		if (FGunfire3DNavigationUtils::AABBIntersectsAABB(InclusionBounds, TileBounds))
		{
			const FBox ExactClippedBounds = TileBounds.Overlap(InclusionBounds);

			FIntBox& NewVoxelBounds = VoxelBounds.AddDefaulted_GetRef();
			FSvoUtils::GetCoordsForBounds(TileBounds.Min, ExactClippedBounds, Config.GetVoxelSize(), NewVoxelBounds.Min, NewVoxelBounds.Max);
		}
	}

	// Only gather geometry if this tile is inside of the navigable bounds
	if (GatherBounds.GetVolume() == 0.0f)
	{
		return false;
	}

	// Generate a voxel-space version of the gather bounds, for use by the generation code
	// to determine if a voxel should be filled in.
	FIntBox FillBounds;
	FillBounds.Min = FSvoUtils::LocationToCoord(PaddedTileMin, GatherBounds.Min, Config.GetVoxelSize());
	FillBounds.Max = FSvoUtils::LocationToCoord(PaddedTileMin, GatherBounds.Max, Config.GetVoxelSize());

	TSharedRef<FTileGenerationData> TileRef = MakeShareable(new FTileGenerationData);
	FTileGenerationData& Tile = TileRef.Get();

	Tile.TileCoord = TileCoord;
	Tile.TileMin = TileBounds.Min;
	Tile.GatherBounds = GatherBounds;
	Tile.FillBounds = FillBounds;
	Tile.VoxelBounds = MoveTemp(VoxelBounds);
	Tiles.Add(TileRef);

	// Gather geometry for all area bounds that touch this tile. If doing asynchronous
	// gather, the sources will be referenced with a thread-safe shared-pointer and
	// geometry will be gathered during the build process.
	UWorld* World = Parent->GetWorld();
	const FNavDataConfig& NavDataConfig = Parent->GetNavDataActor()->GetConfig();

	// Cache off the supported area types for this nav volume
	Parent->GetNavDataActor()->GetSupportedAreaClasses(Tile.CollisionInterface.SupportedAreas);

	if (Config.bDoAsyncGeometryGathering)
	{
		Tile.CollisionInterface.GatherGeometrySources(World, NavDataConfig, GatherBounds);
	}
	else
	{
		Tile.CollisionInterface.GatherGeometry(World, NavDataConfig, GatherBounds);
	}

	// TODO: This isn't accurate if we're doing async gathering, although we currently never do that
	TriCount += Tile.CollisionInterface.CulledTriangles.Num();

	return true;
}

bool FNavSvoTileGenerator::ContainsTileInBounds(const FIntVector& MinTileCoord, const FIntVector& MaxTileCoord) const
{
	for (const TSharedRef<FTileGenerationData>& Tile : Tiles)
	{
		if (FSvoUtils::IsCoordInBounds(Tile->TileCoord, MinTileCoord, MaxTileCoord))
		{
			return true;
		}
	}

	return false;
}

FSvoTile* FNavSvoTileGenerator::GetNextGeneratedTile()
{
	FSvoTile* Tile = nullptr;

	if (NextGeneratedTile < Tiles.Num())
	{
		Tile = &GeneratedTiles[NextGeneratedTile++];
	}

	return Tile;
}

void FNavSvoTileGenerator::AddReferencedObjects(FReferenceCollector& Collector)
{
	for (TSharedRef<FTileGenerationData>& Tile : Tiles)
	{
		for (FNavigationOctreeCollider::TNavigationData& RelevantData : Tile->CollisionInterface.NavigationRelevantData)
		{
			UObject* Owner = RelevantData->GetOwner();
			if (Owner)
			{
				Collector.AddReferencedObject(Owner);
			}
		}
	}
}

bool FNavSvoTileGenerator::FillVoxels(FTileGenerationData& Tile, TBitArray<>& Voxels) const
{
#if PROFILE_SVO_GENERATION
	const uint64 StartCycle = FPlatformTime::Cycles64();
#endif

	if (Tile.CollisionInterface.HasCollisionData())
	{
		// If geometry needs to be gathered on the worker thread, do so now.
		Tile.CollisionInterface.GatherGeometryFromSources(Tile.GatherBounds);
	}

	bool FilledVoxel = false;

	const FVector PaddingOffset(Config.NumPaddingLeafNodesPerAxis * Config.GetLeafResolution() * 0.5);
	const FVector TileMin(Tile.TileMin - PaddingOffset);

	FilledVoxel |= FillTriangles(Tile, TileMin, Voxels);

	if (Tile.CollisionInterface.Blockers.Num() > 0)
	{
		FilledVoxel |= FillBlockers(Tile, TileMin, Voxels);
	}

#if PROFILE_SVO_GENERATION
	GenerateCycles += FPlatformTime::Cycles64() - StartCycle;
	TotalTris += Tile.CollisionInterface.TotalTriangles;
	UsedTris += Tile.CollisionInterface.UsedTriangles;
#endif

	return FilledVoxel;
}

//
// Based on https://github.com/ramakarl/voxelizer/ with a lot of modifications
//
// Our algorithm is to walk from V0 along edge A and edge B one voxel at a time, where
// the current value on the x axis is the same for both edge points. That way we can
// just do a simple line rasterization between the two points at each position to fill
// in the triangle.
//
//        V1
//       / \                Y
//      /   \               ^
//  A  /     \ C            |    Z
//    /       \             |  /
//   /   ___ -- V2          | /
//   ---                    |/
// V0     B                 ---------> X
//
// We've modified the input data so the verts are sorted in ascending order by x, and
// z is the projection axis, so the code is easier to follow. AxisMap contains the
// original axis for x/y/z, for remapping the values back when we need to set a voxel.
//
// There is a lot of special case handling in here for edges parallel to an axis and
// small triangles. It would be nice if we could figure out a way to just handle more
// things in a single algorithm vs having all these special cases bloating things up.
//
bool FNavSvoTileGenerator::FillTriangles(FTileGenerationData& Tile, const FVector& TileMin, TBitArray<>& Voxels) const
{
	bool FilledVoxel = false;

	const float VoxelSize = Config.GetVoxelSize();

	// Remaps a world space location to be in voxel space relative to this tile (1 unit = 1 voxel).
	const auto ToVoxelSpace = [&TileMin, &VoxelSize](const FVector& Pos) -> FVector
	{
		return (Pos - TileMin) / VoxelSize;
	};

	for (const FNavigationOctreeCollider::FTriangle& Tri : Tile.CollisionInterface.CulledTriangles)
	{
		const FVector V0 = ToVoxelSpace(Tri.Vertices[0]);
		const FVector V1 = ToVoxelSpace(Tri.Vertices[1]);
		const FVector V2 = ToVoxelSpace(Tri.Vertices[2]);

		const FVector E0 = V1 - V0;
		const FVector E1 = V2 - V0;
		const FVector E2 = V2 - V1;

		const FVector TriNormal = FVector::CrossProduct(E0, E1).GetUnsafeNormal();

		// Figure out which axis the triangle is most perpendicular to. We'll rasterize the
		// triangle in the other two axes.
		const int32 ProjectAxis =
			FMath::Abs(TriNormal.X) > FMath::Abs(TriNormal.Y) ?
			(FMath::Abs(TriNormal.X) > FMath::Abs(TriNormal.Z) ? 0 : 2) :
			(FMath::Abs(TriNormal.Y) > FMath::Abs(TriNormal.Z)) ? 1 : 2;

		// Pick an arbitrary order for the other two axes to start off with
		int32 AxisA = (ProjectAxis + 1) % 3;
		int32 AxisB = (ProjectAxis + 2) % 3;

		// We want our triangle aligned so its longest edge is along axis A, so we can
		// just move from start to finish on that edge and let it follow along the other
		// two edges.
		{
			const FVector E0Abs = E0.GetAbs();
			const FVector E1Abs = E1.GetAbs();
			const FVector E2Abs = E2.GetAbs();

			const double MaxA = FMath::Max3(E0Abs[AxisA], E1Abs[AxisA], E2Abs[AxisA]);
			const double MaxB = FMath::Max3(E0Abs[AxisB], E1Abs[AxisB], E2Abs[AxisB]);

			if (MaxB > MaxA)
			{
				Swap(AxisA, AxisB);
			}
		}

		FIntVector AxisMap(AxisA, AxisB, ProjectAxis);

		// Remap the coordinates so we're always walking along the x axis and projecting
		// in the z axis, to make the rasterization code easier to follow. We'll convert
		// it back when we're ready to set a voxel.
		TArray<FVector, TInlineAllocator<3>> Verts;
		Verts.Emplace(SwizzleCoord(V0, AxisMap));
		Verts.Emplace(SwizzleCoord(V1, AxisMap));
		Verts.Emplace(SwizzleCoord(V2, AxisMap));

		// Sort the vertices so they're ordered from smallest to largest value along the x axis
		Verts.Sort([](const FVector& A, const FVector& B)
			{
				return A.X < B.X;
			});

		FilledVoxel |= RasterizeTriangle(Tile, Verts, AxisMap, Voxels);
	}

	return FilledVoxel;
}

bool FNavSvoTileGenerator::RasterizeTriangle(FTileGenerationData& Tile, TArrayView<FVector> Verts, FIntVector AxisMap, TBitArray<>& Voxels) const
{
	bool DidSetVoxel = false;

	const auto SetVoxel = [this, &Tile, &AxisMap, &Voxels, &DidSetVoxel](const FVector& Coord)
	{
		const FIntVector VoxelCoord = UnswizzleCoord(FSvoUtils::CoordToFixed(Coord), AxisMap);

		if (Tile.FillBounds.IsInsideOrOn(VoxelCoord))
		{
			const TMortonCode VoxelMorton = FSvoUtils::CoordToMorton(VoxelCoord);
			Voxels[VoxelMorton] = true;
			DidSetVoxel = true;
		}
	};

	const auto RasterizeLine1D = [&SetVoxel](const FVector& StartPos, const FVector& EndPos, const int32 Axis)
	{
		int32 StartVoxel = FMath::TruncToInt(StartPos[Axis]);
		int32 EndVoxel = FMath::TruncToInt(EndPos[Axis]);

		if (StartVoxel > EndVoxel)
		{
			Swap(StartVoxel, EndVoxel);
		}

		FVector CurPos = StartPos;

		for (int32 i = StartVoxel; i <= EndVoxel; ++i)
		{
			CurPos[Axis] = i;
			SetVoxel(CurPos);
		}
	};

	FBox SwizzledBounds;
	SwizzledBounds.Min = SwizzleCoord(FVector(Tile.FillBounds.Min), AxisMap);
	SwizzledBounds.Max = SwizzleCoord(FVector(Tile.FillBounds.Max), AxisMap);

	// Rasterize a line that only moves in the y/z axis, the x axis is fixed
	const auto RasterizeLine2D = [&SwizzledBounds, &RasterizeLine1D, &SetVoxel](const FVector& StartPos, const FVector& EndPos)
	{
		// At the corner of the triangle we'll often get a bunch of points that are in the
		// same voxel, so just early out.
		if (FSvoUtils::CoordToFixed(StartPos) == FSvoUtils::CoordToFixed(EndPos))
		{
			SetVoxel(StartPos);
			return;
		}

		// If this line doesn't intersect the bounds, early out. This saves us a lot of
		// time when we have a big triangle with just the tip poking into the bounds.
		if (!FMath::LineBoxIntersection(SwizzledBounds, StartPos, EndPos, EndPos - StartPos))
		{
			return;
		}

		// If the edge is parallel to either of the axes we'll potentially get a divide by
		// zero in the edge walking code. To avoid that just rasterize it as a straight
		// line in the other axis.
		if (FMath::IsNearlyEqual(StartPos.Y, EndPos.Y, 0.01))
		{
			RasterizeLine1D(StartPos, EndPos, 2);
			return;
		}

		if (FMath::IsNearlyEqual(StartPos.Z, EndPos.Z, 0.01))
		{
			RasterizeLine1D(StartPos, EndPos, 1);
			return;
		}

		// Get the direction and distance to project along the surface of the triangle
		// from our two edge points. Since both points should be at the same position
		// in the x axis this should all be in the y/z plane.
		FVector Direction;
		float EndTime;
		FVector(EndPos - StartPos).ToDirectionAndLength(Direction, EndTime);

		Direction.X = 1;

		// Which direction should we move each time we step the ray to the next voxel
		const FVector DirectionStep = Direction.GetSignVector();

		// The amount to advance the ray time to step one voxel in the given direction
		const FVector VoxelStep = Direction.GetAbs();

		auto CalcAxisIntercept = [&StartPos, &DirectionStep, &VoxelStep](int32 Axis) -> double
		{
			// Gonna divide by zero if this is the case, should have caught this earlier
			ensure(VoxelStep[Axis] != 0.0);

			// Calculate the offset from the start position to the center of the voxel
			const double VoxelCenter = FMath::TruncToInt32(StartPos[Axis]) - StartPos[Axis] + 0.5;
			return ((VoxelCenter * DirectionStep[Axis]) + 0.5) / VoxelStep[Axis];
		};

		// The maximum position we can move to in each axis before switching to the next voxel.
		FVector MaxTime;
		MaxTime.X = 0.0;
		MaxTime.Y = CalcAxisIntercept(1);
		MaxTime.Z = CalcAxisIntercept(2);

		// DDA in the Y/Z plane
		FVector CurPos = StartPos;
		double CurTime = 0.0;

		while (CurTime < EndTime)
		{
			SetVoxel(CurPos);

			// Choose next voxel
			const FVector NextVoxelOffset = (MaxTime.Z < MaxTime.Y) ? FVector::ZAxisVector : FVector::YAxisVector;

			// Advance time
			CurTime = NextVoxelOffset.Z ? MaxTime.Z : MaxTime.Y;

			// Advance x/y/z intercepts by the inverse normal
			MaxTime += NextVoxelOffset / VoxelStep;

			// Advance to next voxel
			CurPos += NextVoxelOffset * DirectionStep;
		}

		SetVoxel(EndPos);
	};

	const FIntVector VoxelCoords[] =
	{
		FSvoUtils::CoordToFixed(Verts[0]),
		FSvoUtils::CoordToFixed(Verts[1]),
		FSvoUtils::CoordToFixed(Verts[2])
	};

	// Check if two coords are in the same voxel in x, or different voxels but close
	// enough that we'll get bad results if we try to divide by the delta.
	const auto TooCloseX = [&VoxelCoords, &Verts](int32 Index0, int32 Index1)
	{
		return 
			(VoxelCoords[Index0].X == VoxelCoords[Index1].X) ||
			FMath::IsNearlyEqual(Verts[Index0].X, Verts[Index1].X);
	};

	// Things get complicated if none of our edges make it to the x or y axis intercept,
	// so avoid trying to handle the edge cases for that and just render lines for the
	// edges and don't bother trying to fill in between them. The only time this happens
	// is with very skinny/small triangles (width of one voxel but potentially longer
	// length).
	//
	// For x, if edge A is too close, we're too close if edge B OR C is too close. We need
	// to check C because if we skip over edge A we need to go to C, so it has to be valid.
	const bool SameX = TooCloseX(0, 1) && (TooCloseX(0, 2) || TooCloseX(1, 2));
	const bool SameY = ((VoxelCoords[0].Y == VoxelCoords[1].Y) && (VoxelCoords[0].Y == VoxelCoords[2].Y));
	if (SameX || SameY)
	{
		// RasterizeLine2D is set up for fixed x values, so if in this case the y values
		// are the same swap x and y so the rasterization will work correctly.
		if (SameY)
		{
			Swap(Verts[0].X, Verts[0].Y);
			Swap(Verts[1].X, Verts[1].Y);
			Swap(Verts[2].X, Verts[2].Y);
			Swap(AxisMap.X, AxisMap.Y);
			Swap(SwizzledBounds.Min.X, SwizzledBounds.Min.Y);
			Swap(SwizzledBounds.Max.X, SwizzledBounds.Max.Y);
		}

		if (VoxelCoords[0] == VoxelCoords[1])
		{
			SetVoxel(Verts[0]);
		}
		else
		{
			RasterizeLine2D(Verts[0], Verts[1]);
		}

		if (VoxelCoords[1] == VoxelCoords[2])
		{
			SetVoxel(Verts[1]);
		}
		else
		{
			RasterizeLine2D(Verts[0], Verts[2]);
		}

		return DidSetVoxel;
	}

	const auto SetupEdge = [](const FVector& StartPos, const FVector& EndPos, FVector& StepOut, FVector& StartOut, double& EndOut)
	{
		const double AxisDelta = EndPos.X - StartPos.X;
		ensure(!FMath::IsNearlyZero(AxisDelta));

		// Calculate how far we need to move in the x axis to get to the edge of our start voxel
		const double InterceptDist = (1.0f - StartPos.X + FMath::Floor(StartPos.X));

		// Make it so our step will always move us 1 unit in the x axis
		StepOut = (EndPos - StartPos) / AxisDelta;
		StartOut = StartPos + StepOut * InterceptDist;
		EndOut = EndPos.X;
	};

	FVector Step0, Step1, CurPos0, CurPos1;
	double EndPos0, EndPos1;

	// If V0 and V1 are in the same voxel along the x axis (means this is a right-angle
	// triangle, or close) just skip edge A and go straight to walking edge C.
	// We also trap the case where they aren't in the same voxel, but are really, really
	// close to each other (at the edge of one voxel, and just over the edge to the next).
	const bool EdgeAVertical = TooCloseX(0, 1);
	const int32 EdgeOffset = EdgeAVertical ? 1 : 0;

	SetupEdge(Verts[0 + EdgeOffset],	Verts[1 + EdgeOffset],	Step0, CurPos0, EndPos0);
	SetupEdge(Verts[0],					Verts[2],				Step1, CurPos1, EndPos1);

	// Walk out from V0 along edge A and B simultaneously using the DDA algorithm. At
	// each step we walk along the surface of the triangle between the two points to
	// fill in the voxels.
	// We've set it up so edge B is the longest, so we use it to
	// calculate when we're done.
	while (CurPos1.X < EndPos1)
	{
		RasterizeLine2D(CurPos0, CurPos1);

		// Advance both edges to the next voxel
		CurPos0 += Step0;
		CurPos1 += Step1;

		// Edge A is either the same length as edge B or shorter. If we hit the end of
		// edge A reset so we're walking edge C. (We don't bother doing this if we also
		// just hit the end of edge B, otherwise we'll generate some garbage data.)
		if (CurPos0.X > EndPos0 && CurPos1.X < EndPos1)
		{
			// FIXME: Hit this case when V2 had a teeny bit larger x value than V1
			// (22.000000000000036 vs 22.000000000000000). Could just continue on the
			// current edge for one more step, but breaking out seems safer. Worst case we
			// miss a voxel we just barely brushed.
			if (FMath::IsNearlyEqual(Verts[1].X, Verts[2].X))
			{
				break;
			}

			SetupEdge(Verts[1], Verts[2], Step0, CurPos0, EndPos0);
		}
	}

	return DidSetVoxel;
}

bool FNavSvoTileGenerator::FillBlockers(const FTileGenerationData& Tile, const FVector& TileMin, TBitArray<>& Voxels) const
{
	const float VoxelSize = Config.GetVoxelSize();

	const auto ToVoxelSpace = [&TileMin, &VoxelSize](const FVector& Pos) -> FVector
	{
		return (Pos - TileMin) / VoxelSize;
	};

	FConvexVolume ConvexVol;

	const FBox VoxelBounds(FVector::ZeroVector, ToVoxelSpace(Tile.GatherBounds.Max));

	bool FilledVoxel = false;

	for (const FConvexNavAreaData& Blocker : Tile.CollisionInterface.Blockers)
	{
		// It's kind of wasteful to build a full convex volume here when these areas
		// can only ever be 2D convex hulls with a min and max height, and we only
		// test them against AABBs. Some other math whiz could probably come up with a
		// better solution, but for now this is the easiest.
		ConvexVol.Planes.Reset();

		FBox BlockerBounds(EForceInit::ForceInit);

		const int32 NumPoints = Blocker.Points.Num();
		const FVector BlockerHeight = FVector(0, 0, (Blocker.MaxZ - Blocker.MinZ) / VoxelSize);

		// Add vertical planes for the sides of the convex hull
		for (int32 PointIdx = 0; PointIdx < NumPoints; ++PointIdx)
		{
			const FVector A = ToVoxelSpace(Blocker.Points[PointIdx]);
			const FVector B = (PointIdx == NumPoints - 1) ? ToVoxelSpace(Blocker.Points[0]) : ToVoxelSpace(Blocker.Points[PointIdx + 1]);

			ConvexVol.Planes.Add(FPlane(A, B, A + BlockerHeight));

			BlockerBounds += (A + FVector(0, 0, (Blocker.MinZ / VoxelSize)));
			if (PointIdx == 0)
			{
				BlockerBounds += (A + FVector(0, 0, (Blocker.MaxZ / VoxelSize)));
			}
		}

		// Cap it off with a top and a bottom
		ConvexVol.Planes.Add(FPlane(FVector(0.0f, 0.0f, (Blocker.MaxZ - TileMin.Z) / VoxelSize), FVector::UpVector));
		ConvexVol.Planes.Add(FPlane(FVector(0.0f, 0.0f, (Blocker.MinZ - TileMin.Z) / VoxelSize), -FVector::UpVector));

		ConvexVol.Init();

		BlockerBounds = BlockerBounds.Overlap(VoxelBounds);

		const uint32 MinCode = FSvoUtils::CoordToMorton(FSvoUtils::CoordToFixed(BlockerBounds.Min));
		const uint32 MaxCode = FSvoUtils::CoordToMorton(FSvoUtils::CoordToFixed(BlockerBounds.Max));

		for (const uint32 CurCode : FMortonIterator(MinCode, MaxCode))
		{
			const FIntVector VoxelCoord = FSvoUtils::MortonToCoord(CurCode);

			if (ConvexVol.IntersectBox(FVector(VoxelCoord) + FVector(0.5), FVector(0.5)))
			{
				if (Tile.FillBounds.IsInsideOrOn(VoxelCoord))
				{
					Voxels[CurCode] = true;
					FilledVoxel = true;
				}
			}
		}
	}

	return FilledVoxel;
}

void FNavSvoTileGenerator::BuildPaddingOffsetCodes()
{
	const uint32 PaddingXY = Config.AgentRadius;
	const uint32 PaddingZ = Config.AgentHalfHeight;
	const uint32 MaxPadExtent = FMath::Max(PaddingXY, PaddingZ);

	TArray<FIntVector> Offsets;

	// Seed our offsets with the origin
	Offsets.Add(FIntVector(0));

	// Brute force all the padding offsets
	for (uint32 CurPadding = 0; CurPadding < MaxPadExtent; ++CurPadding)
	{
		int32 StartNumOffsets = Offsets.Num();

		for (int32 j = 0; j < StartNumOffsets; ++j)
		{
			if (CurPadding < PaddingXY)
			{
				Offsets.AddUnique(Offsets[j] + FIntVector(1, 0, 0));
				Offsets.AddUnique(Offsets[j] - FIntVector(1, 0, 0));
				Offsets.AddUnique(Offsets[j] + FIntVector(0, 1, 0));
				Offsets.AddUnique(Offsets[j] - FIntVector(0, 1, 0));
			}

			if (CurPadding < PaddingZ)
			{
				Offsets.AddUnique(Offsets[j] + FIntVector(0, 0, 1));
				Offsets.AddUnique(Offsets[j] - FIntVector(0, 0, 1));
			}
		}
	}

	// Remove the origin now that we've generated the offsets
	Offsets.RemoveAtSwap(0);

	PaddingOffsetCodes.Reserve(Offsets.Num());

	for (const FIntVector& Offset : Offsets)
	{
		PaddingOffsetCodes.Add(FSvoUtils::CalculateMortonOffset(Offset));
	}

	PaddingOffsetCodes.Sort();
}

void FNavSvoTileGenerator::PadVoxels(const FTileGenerationData& Tile, const TBitArray<>& Voxels, TBitArray<>& PaddedVoxels) const
{
#if PROFILE_SVO_GENERATION
	const uint64 StartCycle = FPlatformTime::Cycles64();
#endif

	// Walk through every leaf in our padded range and for each voxel in the leaf, set
	// every voxel in our input array, and set all the padding voxels. Since we're setting
	// the values on a different array we don't have to worry about over-padding by
	// thinking a padding voxel is a collision voxel. Since we're doing this in Morton
	// order it should be relatively cache efficient.
	for (const uint32 LeafCode : FMortonIterator(Config.MinPaddedLeafCode, Config.MaxPaddedLeafCode))
	{
		const uint32 FirstVoxel = LeafCode << 6;
		const uint32 LastVoxel = FirstVoxel + SVO_VOXELS_PER_LEAF;

		for (uint32 VoxelCode = FirstVoxel; VoxelCode < LastVoxel; ++VoxelCode)
		{
			if (Voxels[VoxelCode])
			{
				PaddedVoxels[VoxelCode] = true;

				for (const uint32 OffsetCode : PaddingOffsetCodes)
				{
					const uint32 VoxelNeighbor = FSvoUtils::OffsetMorton(VoxelCode, OffsetCode);
					PaddedVoxels[VoxelNeighbor] = true;
				}
			}
		}
	}

#if PROFILE_SVO_GENERATION
	PadCycles += FPlatformTime::Cycles64() - StartCycle;
#endif
}

void FNavSvoTileGenerator::CreateTileFromVoxels(const FTileGenerationData& Tile, const TBitArray<>& Voxels, FSvoTile& TileOut) const
{
	LLM_SCOPE_BYTAG(Gunfire3DNavData)

#if PROFILE_SVO_GENERATION
	const uint64 StartCycle = FPlatformTime::Cycles64();
#endif

	const uint32 LeafOffsetCode = FSvoUtils::CalculateMortonOffset(FIntVector(int32(Config.NumPaddingLeafNodesPerAxis / 2)));
	const uint32 VoxelOffsetCode = FSvoUtils::CalculateMortonOffset(FIntVector(int32(Config.NumPaddingLeafNodesPerAxis / 2) * -SVO_VOXEL_GRID_EXTENT));

	const uint32 TileID = TileOut.GetID();
	TileOut.AllocateNodes(Config.GetNumNodesPerTile(), Config.GetTileLayerIndex());

	TArrayView<FSvoNode> Leaves(TileOut.GetNode(SVO_LEAF_LAYER, 0, false), TileOut.GetMaxNodes(SVO_LEAF_LAYER));

	FSvoTile::FSvoLayer& LeafLayer = TileOut.Layers[SVO_LEAF_LAYER];

	// Iterate through our destination leaf nodes and fill them in from our padded data
	for (uint32 LeafCode = 0; LeafCode < (uint32)Leaves.Num(); ++LeafCode)
	{
		FSvoNode& Leaf = Leaves[LeafCode];

		Leaf.Init(FSvoNodeLink(TileID, SVO_LEAF_LAYER, LeafCode), false);
		++LeafLayer.NumNodes;

		// Offset the Morton code for the leaf we're interested in so the unpadded coord
		// we're building references the correct leaf in the padded data we're reading from.
		const uint32 PaddedLeafCode = FSvoUtils::OffsetMorton(LeafCode, LeafOffsetCode);

		const uint32 FirstVoxelCode = PaddedLeafCode << 6;
		const uint32 LastVoxelCode = FirstVoxelCode + SVO_VOXELS_PER_LEAF;

		for (TBitArray<>::FConstIterator It(Voxels, FirstVoxelCode); It && uint32(It.GetIndex()) < LastVoxelCode; ++It)
		{
			if (It.GetValue())
			{
				const uint32 CurrentVoxelCode = It.GetIndex();

				const uint32 UnpaddedVoxelCode = FSvoUtils::OffsetMorton(CurrentVoxelCode, VoxelOffsetCode);
				const FIntVector VoxelCoord = FSvoUtils::MortonToCoord(UnpaddedVoxelCode);

				const bool InBounds = Tile.VoxelBounds.ContainsByPredicate(
					[&VoxelCoord](const FIntBox& Bounds)
					{
						return Bounds.IsInsideOrOn(VoxelCoord);
					});

				if (!InBounds)
				{
					continue;
				}

				// TEMP - convert Morton back to linear. If we rework the voxel bits so
				// they're stored in Morton order we can just do something like this:
				// Voxels.GetRange(FirstVoxel, SVO_VOXELS_PER_LEAF, Leaves[Code].Voxels)
				uint32 VoxelCode = CurrentVoxelCode & 0x3f;
				FIntVector VoxelLoc = FSvoUtils::MortonToCoord(VoxelCode);
				uint32 VoxelIndex = FSvoUtils::GetVoxelIndexForCoord(VoxelLoc);

				Leaf.SetVoxelBlocked(VoxelIndex);
			}
		}
	}

#if PROFILE_SVO_GENERATION
	const uint64 FillCycle = FPlatformTime::Cycles64();
#endif

	if (LeafLayer.NumNodes > 0)
	{
		TileOut.GetNodeInfo().SetNodeState(ENodeState::PartiallyBlocked);
	}

	// Now that we've filled in the voxel data for all the leaf nodes, mark which ones are used
	for (const FSvoNode& Leaf : Leaves)
	{
		for (int32 l = 1; l < Config.GetTileLayerIndex(); ++l)
		{
			bool bCreated;
			FSvoNode* ParentNode = TileOut.EnsureNodeExists(l, Leaf.GetSelfLink().NodeIdx >> (l * 3), bCreated);

			if (Leaf.GetNodeState() != ENodeState::Open)
			{
				ParentNode->SetNodeState(ENodeState::PartiallyBlocked);
			}
		}
	}

	CollapseUnneededNodes(TileOut, TileOut.NodeInfo);

	// TEMP - To create all the internal neighbor links we have to call LinkNeighbors on
	// an octree, so we create a temporary one here to do it. It would be nice to
	// generalize this code so we can run it on a single tile, without an octree.
	FEditableSvo TempOctree(Config);
	TempOctree.AssumeTile(TileOut, true);
	TempOctree.LinkNeighbors();

	FSvoTile* LinkedTile = TempOctree.GetTile(TileID);
	ensure(LinkedTile);
	TileOut.Assume(*LinkedTile);

#if PROFILE_SVO_GENERATION
	NodeCycles += FPlatformTime::Cycles64() - FillCycle;
	FillCycles += FillCycle - StartCycle;
#endif
}

ENodeState FNavSvoTileGenerator::CollapseUnneededNodes(FSvoTile& Tile, FSvoNode& Node) const
{
	ENodeState NodeState = Node.GetNodeState();

	// If this node isn't collapsible (leaf node or already open or blocked), just return
	// the node state.
	if (Node.IsLeafNode() || NodeState != ENodeState::PartiallyBlocked)
	{
		return NodeState;
	}

	// Otherwise, the node is partially blocked with children. Collapse all the children
	// and see if all their states match.
	for (uint8 i = 0; i < 8; ++i)
	{
		FSvoNodeLink ChildLink = Node.GetChildLink(i);
		FSvoNode* ChildNode = Tile.GetNode(ChildLink.LayerIdx, ChildLink.NodeIdx);
		ENodeState ChildState = CollapseUnneededNodes(Tile, *ChildNode);

		// If this is our first child, seed the node state with its state
		if (i == 0)
		{
			NodeState = ChildState;
		}

		// If we find any nodes that don't match our node state we can't collapse this
		// node, so set it to partially blocked.
		if (ChildState != NodeState)
		{
			NodeState = ENodeState::PartiallyBlocked;
		}
	}

	// We collapsed all our children and we're still partially blocked, we can't be
	// collapsed.
	if (NodeState == ENodeState::PartiallyBlocked)
	{
		return NodeState;
	}

	// We're either open or blocked after our children have been collapsed. Reset the
	// children to an unused state and update our node status to the new state.
	FSvoTile::FSvoLayer& ChildLayer = Tile.Layers[Node.GetChildLink(0).LayerIdx];
	ChildLayer.NumNodes -= 8;

	for (uint8 i = 0; i < 8; ++i)
	{
		FSvoNodeLink ChildLink = Node.GetChildLink(i);

		// Reset the child node so it is no longer active
		FSvoNode* ChildNode = Tile.GetNode(ChildLink.LayerIdx, ChildLink.NodeIdx);
		ChildNode->Reset();
	}

	Node.SetNodeState(NodeState);

	return NodeState;
}
